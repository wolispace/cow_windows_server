#!/usr/bin/perl
#------------------------------------------------------------------------ description -------------------
# ga.pl - Game engine by Wallace McGee
# All database concepts concieved and implemented by Wallace McGee
# Copyright (c) Oct 2005 <-- date I sarted writing this perl script.
# This script is the back-end which stores and serves up information about objects in a game
# Written with Joshua
#------------------------------------------------------------------------ setup -------------------------

#-- general concept --
# all information about a location/room is stored in several individual files (one per object) in one folder per location
# when an object (like a player) moved from one room to another, their file is move to a new folder
# front-ends to this game engine call this script (standard http get) with params indicating what changes they are making
# the result is returned in the http reply (web page) containing a list of objects and info about the current location
# eg a front end for player bob sends into that 'bob' has moved to a new x/y - the 'bob' file is updated and the returned string contains a complete list of all objects in this location
#
# On regular intervals this script is called by a front-end just to get an update of what is happenin in the current location
# Chat messages are files with a .cht extension and they expire after 10 seconds.
# the front-end is responsible for making sure a message (altho it exists for 10 seconds and may be returned multiple times during this time) only displays it once to the user.
#
# each object contains these parts to their file name: (eg ledge7_288_160_ledge_2_.dat)
# uniqueID (players must be unique while furniture etc needs only be unique per room (its ok to have to objects called ledge7 solong as they are not in the same folder (location/room)).
# X_Y coords (relative to play area top-left.
# base image name - there must be a gif starting with that name in the /images/ folder
# variation on the image - these are numbers so you can have a variety of similar objects sharing the same image properties (see below). for the north,east,south,west facing players we have 1,2,3,4
#  - eg ledge_2 = /images/ledge_2.gif 
# image properties - there are 5 possible properties for an image:
# 1   = location this image will take the player to when walked over
# 2,3 = x,y position to appear in new location
# 4,5 = width,height how many blocks wide and hight to repeat this gif
#
# There are a whole bunch of delimiters used when sending info back to the front-end
#
# layout info about the current location is stored in room_info.txt 
#
# the file ga_images.js s auto-generated by the contents of the /images/folder

print "Content-type: text/html\n\n";

$product_version = '0.01';   
$offline         = 1 if (-s 'ga_offline.flg' > 0);      # are we running on a localHost or the Internet?
#$d = 1;   # debug
if($offline) {
  $datapath   ='/josh'; # where css and other sundry files are found..
  $basepath   ='/cgi-bin';
  $relpath    ='../josh/';         # files relative to the cgi-bin folder.
}else{
  $datapath   ='/josh'; # where css and other sundry files are found..
  $basepath   ='/cgi-bin';
  $relpath   ='../josh/';
}
$app          = 'ga.pl';
$run          = "$basepath/$app"; # what scripts forms post..
$logfile      = "ga.log";         # logging activity and errors..
$found        = '';               # location whee the named object was found..
$globalchat   = 'globalchat';     # where global messages are sent/read from..
#------------------------------------------------------------------------ start doing things --------------
&parse_input;        # work out what mode and othr params we are requesting
# DEBUG - test params here..
#$params{'m'}='cht';
#$params{'c'}='bob^this is something';
#$params{'loc'}='lab1';
#$params{'g'}='1';

$params{'loc'} =~ s/`/\//g; # convert backtick to slash so we can have folders in folders
my $rstring = &analyse_cmds; # display the results of the mode we requested
$rstring =~ s/\//`/g;
print $rstring;


#------------------------------------------------------------------------ main switchboard logic functions --------------
sub analyse_cmds {  # workout what to do..
  $m = $params{'m'};
  if ($m eq 'status') {     return &m_default;
  } elsif ($m eq 'login') { return &m_login;
  } elsif ($m eq 'reg') {   return &m_reg;
  } elsif ($m eq 'move') {  return &m_move;
  } elsif ($m eq 'info') {  return &m_info;
  } elsif ($m eq 'img') {   return &m_img;
  } elsif ($m eq 'del') {   return &m_del;
  } elsif ($m eq 'cht') {   return &m_cht;
  } else {                  return &m_show;
  }
}
#-------------------------------------------------------------------------- main functions ---------
sub m_show { # show the current position of all objects in the named folder..
  my $ret = '';                        # the string we return
  my $loc = $relpath.$params{'loc'};   # which folder
  $ret = &scan_folder($loc);           # return a string of all files in this folder
  $ret .= '~'.&scan_folder($relpath.'globalchat');  # return a string of all chat messages on the globalchat folder
  
  #&logit('loc '.$loc.' '.$ret);
  return 'loc_'.$params{'loc'}.'~'.$ret;
}

sub m_move { # move the named object - rename the file to match..
  my $ret = '';                        # the string we return
  my $loc = $relpath.$params{'loc'};   # which folder
  my @obj_list = split(/\~/,$params{'u'});# make a list of what to move # a reverse string "&u=player_60_60~rock1_40_95"
  my $updated = 0;
  #&logit($params{'u'});
  opendir(DIR, $loc);
  my @all_files = sort readdir(DIR);      # read all files from this folder..
  closedir DIR;
  foreach my $this_file(@all_files) {     # loop through each file
    foreach my $obj(@obj_list){
      my ($id,$ex,$ey) = split(/\_/,$obj);  # split string "player1_100_20" into elements..  
      if($this_file =~ m/$id\_.+dat/i){   # if its a dat file eg "player1_100_180.dat"
        rename $loc.'/'.$this_file,"$loc/$obj.dat";     # rename it to "$obj.dat";
        $updated=1;
      }
    }
  }
  if($updated==0){
    my $this_file = $params{'u'};
    open(OUT,">$relpath$loc/$this_file.dat");
    print OUT " ";
    close(OUT);
    #&logit("adding $relpath$loc/$this_file.dat");
  }
  return &m_show.$room_info;                          # retuen the new positions
}

sub m_info { # returns the info about this room..
  my $ret = '';
  my $loc = $params{'loc'};
  my $upd = $params{'upd'};         # new info for this room..
  if($upd ne ''){
    open(OUT,">$relpath$loc/room_info.txt"); # default room info
    print OUT $upd;
    close(OUT);
  }

  open(IN,"<$relpath$loc/room_info.txt");
  my @content = <IN>;
  close(IN);
  my $cstring = join('^',@content);
  if($cstring eq ''){
    $cstring = "grass1^15^10";
    
	mkdir("$relpath$loc",0);          # make the folder..
    open(OUT,">$relpath$loc/room_info.txt"); # default room info
    print OUT $cstring;
    close(OUT);
  } 
  $ret = '~roominfo_'.$cstring; # join into one long string seperated by ^
  return $ret;
}

sub m_img { # save info about images in js file..
  my $done =0;
  my $iname=$params{'iname'};
  my $ival =$params{'ival'};
  my $newlist = ''; 
  my $images = "\nfunction drawMenu(){\nif(builder!=1){return;}\n"; 
  my $tiles = "\n ret='floor: <select id=\"roomf\" class=\"inputtext\" onChange=\"saveRoomInfo()\" style=\"font-size:200%\">';\n";
  my $ret = ''; 

  open(IN,"<$relpath"."ga_images.js");
  my @content = <IN>;
  close(IN);
  foreach my $line (@content){
    $img='';
    $val='';
    $line=~m/\[\'(.+)\'\]\s+=\s+\'(.+)\';/;
    $img=$1;
    $val=$2;
    if($line =~ /imgs\[/){
      if($img eq $iname){
        $newlist .= "imgs['$iname'] = '$ival';\n";
        $ims{$iname}=$ival; # buid an array of used images..
        $done=1;
      }else{
        $newlist .= "imgs['$img'] = '$val';\n";
        $ims{$img}=$val; # buid an array of used images..
      }
    }
  }
  if(($done eq 0)&&($iname ne '')){
    $newlist .= "imgs['$iname'] = '$ival';\n";
    $ims{$iname}=$ival; # buid an array of used images..
  }
  open(OUT,">$relpath"."ga_images.js"); # default room info
  print OUT $newlist;
  close(OUT);
  # scan images folder and make arrays of the images handle images with inderscores differently..
  opendir(DIR, $relpath.'images');
  my @all_files = sort readdir(DIR);      # read all files from this folder..
  closedir DIR;
  foreach my $this_file(@all_files) {     # loop through each file
    my ($fname,$fext) = split(/\./,$this_file);
    if(($fname ne '')&&($fext eq 'gif')){
      if($fname =~ m/_/i){
        my ($itype,$iface) = split(/\_/,$fname);
        if($itype ne $otype){
          if($ims{$itype} eq ''){
            $newlist .= "imgs['$itype'] = '1,1,0,0';\n"; # add a default image pos
          }
          $images .= " addImage('<br>','')\n"; # add a blank between sets..
        }
        $images .= " addImage('$itype','$iface')\n"; # general object..
        $otype = $itype;
        
      }else{
        $tiles .= " ret = ret + addTile('$fname');\n"; # a tile bject..
      }
    }
  }
  $tiles .= " ret = ret + '</select>'";
  open(OUT,">$relpath"."ga_images.js"); # default room info
  print OUT $newlist.$images."\n var e = document.getElementById('menu');".$tiles."\n e.innerHTML = ret+e.innerHTML;}";
  close(OUT);
}

sub m_del { # delete the named object..
  my $ret = '';                        # the string we return
  my $loc = $relpath.$params{'loc'};   # which folder
  my $tfile = $params{'d'};
  opendir(DIR, $loc);
  my @all_files = sort readdir(DIR);      # read all files from this folder..
  closedir DIR;
  foreach my $this_file(@all_files) {     # loop through each file
    if($this_file =~ m/$tfile/i){
      unlink $loc.'/'.$this_file;                # delete the file specified..
    }
  }
  return &m_show; #.'~roominfo_'.$room_info;                          # retuen the new positions
}

sub m_cht { # write chat message to this folder..
  my $loc = $params{'loc'};   # which folder
  my $tfile = $params{'c'};
  my $global = $params{'g'};
  my $cloc = ($params{'g'} ne '') ? $globalchat : $loc; # if param G is not blank then its a global msg..
  $tfile =~ m/(.+)\^(shout )(.+)/i;
  if($3 ne ''){
    $tfile = $1.'^'.$3;
    $cloc = $globalchat;
  }
  #print ">$relpath$cloc/$tfile".'.cht'."\n";
  open(OUT,">$relpath$cloc/$tfile".'.cht'); # create chat msg file in correct folder..
  close(OUT);
  return &m_show; #.'~roominfo_'.$room_info;                          # return all info about the current location..
}

sub m_login { # initially just generate ra pid and set a new object for this..
  my $n = $params{'n'};
  my $room_info = '';               # info about this room..
  # make a new object to match this..
  &search_obj($relpath,$n);       # look for this named object in these folders..
  if($found eq ''){
    $found='notfound'; # return notfound to game so user can try again
  }else{
    open(IN,"<$relpath$found/room_info.txt");
    my @content = <IN>;
    close(IN);
    $room_info = join('^',@content); # join into one long string seperated by ^
  }
  my $ret = 'pid_'.$n.'~start_'.$found.'~roominfo_'.$room_info;
  #&logit("login for $n = $ret");
  return $ret;

}

sub m_reg { # register as a new user..
  my $rn    = $params{'rn'};
  my $rw    = $params{'rw'};
  my $rd    = $params{'rd'};
  my $rh    = $params{'rh'};
  my $loc   = $params{'rl'};
  my $ri    = $params{'ri'};
  my $re    = $params{'re'};
  # make sure this objects does not already exist..
  &search_obj($relpath,$rn);       # look for this named object in these folders..
  if($found ne ''){
    $ret = "reg_exists~$found";
  }else{
    open(OUT,">$relpath$loc/$rn".'_'.$rx.'_'.$ry.'_'.$ri.'_'.$rd.'_player.dat');   #                      1   2
    print OUT "$rw^$re^$rh";                                         # player file content="pwd^hp^ 
    close(OUT);
    $ret = "reg_$rn^$rx^$ry^$ri^$rd^player^$loc";  # name_x_y_img_dir_player_loc
  }
  return $ret;
}

sub search_obj { # search all folders for the named obj..
  my $ret = '';
  my $tdir = $_[0];
  my $tobj = $_[1];
  return if ($recount++ > 50);
  opendir(DIR, $tdir);
  #print "looking in $tdir\n";
  my @all_files = sort readdir(DIR);   # read all files from this folder..
  closedir DIR;
  foreach my $this_file(@all_files) {  # loop through each file
    if(($this_file ne '.')&&($this_file ne '..')){
      if(-d $tdir.'/'.$this_file){
        $ret = search_obj($tdir.$this_file.'/',$tobj);
      }else{
        if($this_file =~ /$tobj(_)/){
          $found = $tdir; # this folder
          $found=~ s/$relpath(.+)\//$1/; # return the room name

          #print "($ret)";
          return $ret;
        }else{
          #print "still looking $this_file\n";
        }
      }
    }
  }
  #print "returning from $tdir ($ret)\n";
  #return $ret;
}


#-------------------------------------------------------------------------- base functions -------
sub logit { # logs to file..
  open(OUT,">>$relpath".$params{'loc'}."/$logfile");
  print OUT $params{'loc'}.' '.$_[0]."\n";
  close(OUT);
  open(OUT,">>$logfile");
  print OUT $params{'loc'}.' '.$_[0]."\n";
  close(OUT);
}

sub scan_folder { # returns a string of all files in the specified folder..
  my $this_dir = $_[0];
  my $ret = '';                        # the string we return
  opendir(DIR, $this_dir);
  my @all_files = sort readdir(DIR);   # read all files from this folder..
  closedir DIR;
  foreach my $this_file(@all_files) {  # loop through each file
    if($this_file =~ m/(.+).dat/i){        # if its a dat file eg "player1_100_180.dat"
      $ret .= $1.'~';          # add it to our string we return, delimited..
    }elsif($this_file =~ m/(.+).cht/i){
      my $chat = $1;
      my $fdate = (stat("$this_dir/$this_file"))[9];
      if((time-$fdate)>10){
        unlink "$this_dir/$this_file";  # delete the old chat msg..
        #$ret .= $fdate.'_cht^'.'deleting '.$this_file.'_'.(((time-$fdate)/60)>30).'~';          # add it to our string we return, delimited..
      }else{
        $ret .= $fdate.'_cht^'.$chat.'~';          # add it to our string we return, delimited..
      }
    }
  }
  return $ret;
}


sub parse_input {  # Get the form input..
  read(STDIN, $buffer, $ENV{'CONTENT_LENGTH'});   # get form values..
  $buffer .= '&'.$ENV{'QUERY_STRING'};   # get the commandline URL input..
  $bbuffer = $buffer;
  $buffer =~ s/%26/_amp_/g;               #ADD 23/01/02 PP
  $buffer =~ s/%2B/_plus_/ig;
  $buffer =~ s/%5C/_backslash_/ig;
  $buffer =~ s/%([a-fA-F0-9][a-fA-F0-9])/pack("C", hex($1))/eg;
  $buffer =~ tr/+/ /;
  $buffer =~ s/_backslash_/\\\\/ig;
  $buffer =~ s/_plus_/\+/ig;
  $buffer =~ s/\@/\\\@/g;
  $buffer =~ s/(\$|'|")/\\$1/g; #' escape these chars..
  $buffer =~ s/ \= / _equals_ /g;
  my @pairs = split(/&/, $buffer);
  foreach $pair (@pairs) {
    my ($name, $value) = split(/=/, $pair,2);
    #$value =~ tr/==/=/; # convert back to
    $value =~ s/_amp_/&/g;                      #ADD 03/03/03 convert back to &
    $value =~ s/ _equals_ / \= /g;
    if($name ne '') {
      if($params{$name} eq '') {
        $params{$name} = $value; # build hash array
      } else {
        if($name ne 'p') {
          $params{$name} .= $params_delim.$value; # build hash array
        }
      }
   #** this converts it into a variable automatically.. maybe we dont want this..
   $this_field_name = '$'.$name;
   $this_param_value = $params{$name};
   eval($this_field_name.' = "'.$this_param_value.'"');
    }
  }
  return $buffer;
}

sub new_pid() {
  # generates a new pid - if length 7 then the chance of a duplicate is 1:million..
  my $len=($_[0] eq '') ? 5 : $_[0];
  my $ret='';
  while(length($ret)<$len){
    my $t1 = '~';
    $t1 = chr(int(rand(122-48)+48)) while($t1 =~ m/\W/);
    $ret .= $t1;
  }
  $ret =~ s/_/o/g;
  $ret =~ s/^\d/c/; # replace the first number with a letter..
  # check for a matching pid.. and re-generate with a higher number if found..

  #my ($found_pid) = &db_find_first('objects','pid',"pid='$ret'");
  #if ($found_pid ne '') {
  #  $ret = &new_pid(length($p+1));
  #}
  return $ret;
}

